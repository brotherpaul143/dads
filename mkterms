#!/usr/bin/perl -w
# $Id: mkterms,v 1.51 2001/04/09 14:57:18 black Exp $
# *created  "Tue Sep  8 11:36:37 1998" *by "Paul E. Black"
# *modified "Mon Apr  9 10:41:43 2001" *by "Paul E. Black"
#
# Collect all terms and format them for web pages.
#	Paul E. Black <paul.black@nist.gov> or <p.black@acm.org>
#	http://hissa.nist.gov/~black/
#    Modified By Fabrizio Fioravanti (search for FF)
#	<fioravan@dsi.unifi.it>, <fioravanti@computer.org>
#	http://www.dsi.unifi.it/~fioravan/
#
#------------------------------------------------------------------------

$useMsg="usage: mkterms [--help] [--all] [--page path] [--url root]";
$minOperands = 0;
$maxOperands = 0;

#------------------------------------------------------------------------
#
# This software was developed at the National Institute of Standards 
# and Technology by employees of the Federal Government in the course 
# of their official duties.  Pursuant to title 17 Section 105 of the 
# United States Code this software is not subject to copyright 
# protection and is in the public domain. 
# 
# We would appreciate acknowledgement if the software is used.
#
# Paul E. Black paul.black@nist.gov
#
#------------------------------------------------------------------------

# CONFIGURATION SECTION:
require 'mkcommon';

# true prints information as this runs
$verbose = 1;

# true generates all HTML pages
$writeAllPages = "";

# the first and ending parts of each entry page
$ENTINTRO="entry.intro";
$ENTCONCL="entry.concl";

#------------------------------------------------------------------------
#
# you should not have to edit anything below this
#
#------------------------------------------------------------------------

#------------------------------------------------------------------------------
#       Command line handling
#------------------------------------------------------------------------------

while ($#ARGV >= 0) {
    if ($ARGV[0] =~ /^--?h(e(lp?)?)?/) {
        print "$useMsg\n";
        print "    where\n";
        print "\t--help    Print this message and exit\n";
        print "\t--all     Write HTML pages for all terms\n";
        print "\t--        End of options\n";
        print "    This creates HTML pages and cross references for terms\n";
        exit 0;
    } elsif ($ARGV[0] =~ /^--?a(ll?)?$/) {
	$writeAllPages = 1;
	shift;
    } elsif ($ARGV[0] =~ /^--?p(a(ge?)?)?$/) {
	shift;
	$WEB_DIR = shift;
    } elsif ($ARGV[0] =~ /^--?u(rl?)?$/) {
	shift;
	$URL_DIR = shift;
    } elsif ($ARGV[0] eq "--") {
        shift;
    } elsif ($ARGV[0] =~ /^-/) {
        print "unknown option: $ARGV[0]\n";
        print "$useMsg\n";
        exit 1;
    } else {
        # end of options
        last;
    }
}

$numberOfOperands = 1 + $#ARGV; # - $optind
if ($numberOfOperands < $minOperands || $maxOperands < $numberOfOperands) {
    print "Wrong number of operands\n";
    print "$useMsg\n";
    die;
}

# so -w doesn't complain about these being used only once
$dummy = $TERMS_DIR;
$dummy = $OUT_DIR;
$dummy = %types;
undef $dummy;

# read/write by owner, readable by everyone else
umask(0022);

# Step I: read initialization and config files
&readConfigFiles;

# Step II: read term entries
&readTermEntries;

#------------------------------------------------------------------------
#
# Step III: write each entry to its own page
#
#------------------------------------------------------------------------

sub rewriteXrefs {
    # rewrite cross references ({...}) as href's (to entries, not files)
    #print "STEP 1: $_[0] \n"; # for debugging
    $_[0] =~ s|%|%P|go; # preserve our escape character
    $_[0] =~ s|\\{|%R|go; # escape {'s in HTML markup
    #print "STEP 3: $_[0] \n"; # for debugging
    # rewrite complex references ( {text#xref} ) first
    $_[0] =~ s|{([^}]+)\#([^}]+)}|<a href="\#$2"><em>$1</em></a>|go;
    # now rewrite simple references ( {textref} )
    $_[0] =~ s|{(.+?)}|<a href="\#$1"><em>$1</em></a>|go;
    # change escaped characters back
    $_[0] =~ s|%R|{|go; # unescape {'s for final display
    $_[0] =~ s|%P|%|go;
    #print "STEP 7: $_[0] \n"; # for debugging

    # change entry names to their corresponding files and
    #   report any dangling xrefs
    foreach $xref (split /^.*?href="\#|".*?href="\#|".*?$|^.*$/, $_[0]) {
	next if ($xref eq ""); # above RE starts with a null split
	#print "\nFound $xref\n"; # for debugging
	my $strippedXref = $xref;
	$strippedXref =~ s/\$([^\$]*)\$/$1/go; # strip LaTeX markers
	my $indexXref = $strippedXref;
	if (! defined $entriesForXref{$indexXref}) {
	    # try the singular, i.e., removing a trailing "s"
	    $indexXref =~ s/s$//;
	    if (! defined $entriesForXref{$indexXref}) {
		# try lower case on first character
		$indexXref = $strippedXref; # start again
		substr($indexXref, 0, 1) =~ tr/A-Z/a-z/;
		if (! defined $entriesForXref{$indexXref}) {
		    # try removing a trailing "es"
		    $indexXref = $strippedXref; # start again
		    $indexXref =~ s/es$//;
		    if (! defined $entriesForXref{$indexXref}) {
			print "\n    *****Unknown HyperREFerence to \"$xref\" in $_[1]\n";
			next;
		    }
		}
	    }
	}

	my $xrefKey = $entriesForXref{$indexXref};
	#print "\nit is $xrefKey\n";
	%xrefEntry = %{$entries{$xrefKey}};
	my($xrefFile) = "$xrefEntry{BASEFILENM}.html";

	# quote special RE characters
	my $xrefQ = quoteREpatterns("\#$xref");

	#print "subs is /$xrefQ/$xrefFile/\n"; # for debugging
	$_[0] =~ s/$xrefQ/$xrefFile/;
    }
}

# Rewrite external HREFs to use the NIST "exit script" described at
#	http://webservices.nist.gov/exit_nist.htm
sub rewriteHrefs {
    foreach $xref (split /^.*?href="|".*?href="|".*?$|^.*$/i, $_[0]) {
	next if ($xref eq ""); # above RE starts with a null split
	next if $xref =~ /nist\.gov/; # don't rewrite internal links
	#print "\nFound $xref\n"; # for debugging

	# quote special cgi characters
	my($xrefCGIQ) = $xref;
	$xrefCGIQ =~ s|%|%25|g;
	$xrefCGIQ =~ s| |%20|g;
	$xrefCGIQ =~ s|"|%22|g;
	$xrefCGIQ =~ s|\#|%23|g;
	$xrefCGIQ =~ s|&|%26|g;
	$xrefCGIQ =~ s|\+|%2B|g;
	#$xrefCGIQ =~ s|/|%2F|g;
	$xrefCGIQ =~ s|;|%3B|g;
	$xrefCGIQ =~ s|=|%3D|g;
	$xrefCGIQ =~ s|~|%7E|g;
	my($xrefExit) = "\"http://www.nist.gov/cgi-bin/exit_nist.cgi?url=$xrefCGIQ\"";

	# quote special RE characters
	my $xrefQ = quoteREpatterns("\"$xref\"");

	#print "subs is /$xrefQ/$xrefExit/\n"; # for debugging
	$_[0] =~ s/$xrefQ/$xrefExit/;
    }
}

print STDERR "Writing terms\n" if ($verbose);

# find the age of the younger of the entry intro and entry conclusion 
# files, so we can check whether we need to rewrite the HTML page.
$ENTNEWESTMOD = -M $ENTCONCL;
if (-M $ENTINTRO < $ENTNEWESTMOD) {
    $ENTNEWESTMOD = -M $ENTINTRO;
}

$prevdname = ""; # check for repeated entries

# sort the entries
@sortedentries = sort keys %entries;
#print @sortedentries;
$numEntries = 0;

#------------------------------------------------------------------------
#
# Step IIIc: write each entry to its own page
#
#------------------------------------------------------------------------

for $ekey (@sortedentries) {
    %thisEntry = %{$entries{$ekey}};
    #print %thisEntry; print "\n";

    my($ename) = $thisEntry{NAME};
    my($tname) = $thisEntry{TNAME};
    my $dname = $thisEntry{DNAME};
    my $xname = $thisEntry{XNAME};
    if (defined $thisEntry{MODIFIED}) {
	$moddate = $thisEntry{MODIFIED};
    } else {
	$moddate = "sometime";
    }

    # check for repeated entry names.  This happens when I change the
    # file name for an entry, but forget to remove the old file.
    if ($dname eq $prevdname) {
	print "\n    *****Repeated entry: $dname\n";
    }
    $prevdname = $dname;

    $termpage="$OUT_DIR/$thisEntry{BASEFILENM}.html";
    $termurl ="$URL_DIR/$termpage";
    $termfile="$WEB_DIR/$termpage";

    $numEntries++;

    ###########################################################
    # Write the entry HTML page (if necessary)
    ###########################################################

    # should we write the HTML page?
    if ((! -e $termfile) || $writeAllPages
	|| (-C $termfile > -M "$TERMS_DIR/$thisEntry{BASEFILENM}.trm")
	|| (-C $termfile > $ENTNEWESTMOD)) {
	# write the page
	print STDERR "$tname, " if ($verbose);
    } else {
	# don't need to write the page
	print STDERR ", " if ($verbose); # just a "working" mark
	next;
    }

    unlink($termfile) if (-e $termfile);
    open(TERMPAGE, "> $termfile")
	|| die ("Cannot create term web page $termfile, stopped");

    # copy term page intro, replacing variables as appropriate
    open(FHANDLE, "< $ENTINTRO")
	|| die("Cannot open $ENTINTRO\n");
    $runtime = localtime;
    while (<FHANDLE>) {
	s/\$NAME/$ename/g;
	s/\$DNAME/$dname/g;
	s/\$TNAME/$tname/g;
	s/\$RUNDATE/$runtime/g;
	s/\$MODDATE/$moddate/g;
	s/\$URL/$termurl/g;
	print TERMPAGE $_;
    };
    close(FHANDLE);

    if (defined $thisEntry{TYPE}) {
	my($etype) = $thisEntry{TYPE};
	my($elongtype) = $types{$etype};
	$elongtype =~ tr/A-Z/a-z/; # make lower case
	$elongtype =~ s/s$//o; # make singluar (not plural)
	print TERMPAGE "<P>\n($elongtype)\n\n";
    }
    print TERMPAGE "<P>\n<strong>Definition:</strong>\n";
    if (defined $thisEntry{DEFN}) {
	my($edefn) = $thisEntry{DEFN};
	# convert cross references ({...}) to href's
	&rewriteXrefs($edefn, $ename);
	# convert LaTeX expressions to HTML
	&rewriteLatex($edefn);
	print TERMPAGE "$edefn\n";
    } else {
	print TERMPAGE << "NO_DEFN_MESSAGE";
(no definition here, yet, but
<A HREF=\"../$MAINPAGE\#needHelp\">you can help</A>.)
NO_DEFN_MESSAGE
    }
    if (defined $thisEntry{FORML}) {
	my($eformlDef) = $thisEntry{FORML};
#	# convert cross references ({...}) to href's
#	&rewriteXrefs($eformlDef, $ename);
#	# convert LaTeX expressions to HTML
#	&rewriteLatex($eformlDef);
	print TERMPAGE "<P>\n<strong>Formal Definition:</strong> $eformlDef\n";
    }
    if (defined $thisEntry{XREFS}) {
	my($exrefs) = $thisEntry{XREFS};
	# change cross references ({...}) to href's
	&rewriteXrefs($exrefs, $ename);
	# convert LaTeX expressions to HTML
	&rewriteLatex($exrefs);
	# have exactly one space after a comma
	$exrefs =~ s|,\s*|, |go;
	print TERMPAGE "<P><strong>See also</strong>\n$exrefs.\n";
    }
    if (defined $thisEntry{AKA}) {
	my($ealiases) = $thisEntry{AKA};
	# have exactly one space after a comma
	$ealiases =~ s|,\s*|, |go;
	# change cross references ({...}) to href's
	&rewriteXrefs($ealiases, $ename);
	print TERMPAGE "<P><strong>Also known as</strong> $ealiases.\n";
    }
    if (defined $thisEntry{NOTES}) {
	my($enotes) = $thisEntry{NOTES};
	# convert cross references ({...}) to href's
	&rewriteXrefs($enotes, $ename);
	# convert LaTeX expressions to HTML
	&rewriteLatex($enotes);
	print TERMPAGE "<P><em>Note:\n$enotes</em>\n";
    }
    if (defined $thisEntry{AUTHOR}) {
	my($eauth) = $thisEntry{AUTHOR};
	$eauth =~ s| *([^,]+)|<a href="../$MAINPAGE\#author$1">$1</a>|go;
	# SKIMP write plural if more than one
	print TERMPAGE "<P>Author: $eauth\n";
    }
    if (defined $thisEntry{IMPL}) {
	my($eimpls) = $thisEntry{IMPL};
	# rewrite HREFs with exit_nist script
	&rewriteHrefs($eimpls);
	# SKIMP write plural if more than one
	print TERMPAGE "<H2>Implementation</H2>\n$eimpls\n";
    }
    if (defined $thisEntry{LINKS} || defined $thisEntry{BIB}) {
	print TERMPAGE "<H2>More information</H2>\n";
    }
    if (defined $thisEntry{LINKS}) {
	my($elinks) = $thisEntry{LINKS};
	# rewrite HREFs with exit_nist script
	&rewriteHrefs($elinks);
	print TERMPAGE "$elinks\n";
    }
    if (defined $thisEntry{BIB}) {
	my($ebiblio) = $thisEntry{BIB};
	print TERMPAGE "<p>\n$ebiblio\n</p>\n";
    }
    print TERMPAGE "\n";

    # copy term page conclusion, replacing variables as appropriate
    open(FHANDLE, "< $ENTCONCL")
	|| die("Cannot open $ENTCONCL\n");
    while (<FHANDLE>) {
	s/\$NAME/$ename/g;
	s/\$DNAME/$dname/g;
	s/\$TNAME/$tname/g;
	s/\$RUNDATE/$runtime/g;
	s/\$MODDATE/$moddate/g;
	s/\$URL/$termurl/g;
	print TERMPAGE $_;
    };
    close(FHANDLE);

    close(TERMPAGE);
}

print STDERR "\n" if ($verbose);

print "Wrote $numEntries terms\n";

exit;

# end of $Source: /home/black/DADS/dads/RCS/mkterms,v $
