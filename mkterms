#!/usr/bin/perl -w
# $Id: mkterms,v 1.48 2001/01/08 18:58:11 black Exp $
# *created  "Tue Sep  8 11:36:37 1998" *by "Paul E. Black"
# *modified "Mon Jan  8 13:55:57 2001" *by "Paul E. Black"
#
# Collect all terms and format them for web pages.
#	Paul E. Black <paul.black@nist.gov> or <p.black@acm.org>
#	http://hissa.nist.gov/~black/
#    Modified By Fabrizio Fioravanti (search for FF)
#	<fioravan@dsi.unifi.it>, <fioravanti@computer.org>
#	http://www.dsi.unifi.it/~fioravan/
#
#------------------------------------------------------------------------

$useMsg="usage: mkterms [--help] [--all]";
$minOperands = 0;
$maxOperands = 0;

#------------------------------------------------------------------------
#
# This software was developed at the National Institute of Standards 
# and Technology by employees of the Federal Government in the course 
# of their official duties.  Pursuant to title 17 Section 105 of the 
# United States Code this software is not subject to copyright 
# protection and is in the public domain. 
# 
# We would appreciate acknowledgement if the software is used.
#
# Paul E. Black paul.black@nist.gov
#
#------------------------------------------------------------------------

$justTesting = "";

# CONFIGURATION SECTION:
# set the following
# - The path of the directory which has term files.
$TERMS_DIR="Terms";
# - The extension of term files (.trm for now).
$TERM_EXT ="trm";
# - The (path) name of file with the authors' initials, name, ref., etc. file
$AUTHORS  ="authors.data";
# - The (path) name of file with the areas into which entries are classified
$AREAS	  ="areas.data";
# - The (path) name of file with the admissible types of the entries
$TYPES	  ="types.data";
# - The (path) name of the file with PERL substitutions to change LaTeX 
#	to the target language, e.g., HTML
$LATEXREWRITES = "latex2html.data";
# - The file system path of the web pages.
$WEB_DIR  ="Target";
# - The path of the directory where term pages go, that is,
#	$WEB_DIR/$OUT_DIR/termFile.html is the path for termFile.trm
$OUT_DIR  ="HTML";
# - The URL to the main directory, that is,
#	$URL_DIR/$WEBPAGE.html is the URL for the main page and
#	$URL_DIR/$OUT_DIR/termFile.html is the URL for termFile.trm
$URL_DIR  ="http://hissa.nist.gov/dads";
# - The name of final (combined or main) web page, less extension 
#	(.html), it is written to $WEB_DIR/$WEBPAGE.html
$WEBPAGE  ="terms";
# - The name of the two-level index web page, less extension
#	(.html), it is written to $WEB_DIR/$WEBPAGE.html
$TWOLEVEL ="terms2";

#$ownerEmail = "paul.black\@nist.gov";

# true prints information as this runs
$verbose = 1;

# true generates all HTML pages
$writeAllPages = "";

# the first and ending parts of each entry page
$ENTINTRO="entry.intro";
$ENTCONCL="entry.concl";

#------------------------------------------------------------------------
#
# you should not have to edit anything below this
#
#------------------------------------------------------------------------

#------------------------------------------------------------------------------
#       Command line handling
#------------------------------------------------------------------------------

while ($#ARGV >= 0) {
    if ($ARGV[0] =~ /^--?h(e(lp?)?)?/) {
        print "$useMsg\n";
        print "    where\n";
        print "\t--help    Print this message and exit\n";
        print "\t--all     Write HTML pages for all terms\n";
        print "\t--        End of options\n";
        print "    This creates HTML pages, cross references, and indices for terms\n";
        exit 0;
    } elsif ($ARGV[0] =~ /^--?a(ll?)?/) {
	$writeAllPages = 1;
	shift;
    } elsif ($ARGV[0] eq "--") {
        shift;
    } elsif ($ARGV[0] =~ /^-/) {
        print "unknown option: $ARGV[0]\n";
        print "$useMsg\n";
        exit 1;
    } else {
        # end of options
        last;
    }
}

$numberOfOperands = 1 + $#ARGV; # - $optind
if ($numberOfOperands < $minOperands || $maxOperands < $numberOfOperands) {
    print "Wrong number of operands\n";
    print "$useMsg\n";
    die;
}

# defined entry properties
%properties = (
	NAME	=> 1,
	TYPE	=> 1,
	AREA	=> 1,
	DEFN	=> 1,
	AKA	=> 1,
	XREFS	=> 1,
	BIB	=> 1,
	NOTES	=> 1,
	AUTHOR	=> 1,
	IMPL	=> 1,
	LINKS	=> 1
);

# get the year (CCYY), month (01-12), day (01-31), etc.  This is Y2K compliant.
#($sec,$min,$hr,$mday,$mon,$yr,$wday,undef,undef) = localtime;
# SKIMP - timezone (like MDT or EST) not printed
#printf("%3s %3s %2d %02d:%02d:%02d %4d\n",
#        (Sun,Mon,Tue,Wed,Thu,Fri,Sat)[$wday],
#        (Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec)[$mon],
#        $mday, $hr, $min, $sec, 1900+$yr);
$now = localtime;

# copy the file to the file handle
# example: append the contents of $TEMP_FILE to $target
#	open(TARGET, "> $target");
#	&concatenate($TEMP_FILE, TARGET);
#	close(TARGET);
sub concatenate {
    my($filename, $handle) = @_;
    open(FHANDLE, "< $filename")
	|| die("Cannot open $filename\n");
    while (<FHANDLE>) {print $handle $_};
    close(FHANDLE);
}

# read/write by owner, readable by everyone else
umask(0022);

# rename the existing page (topage) to be a backup, and rename the 
# new page (frompage) to be the existing page.  For instance, if
# there is page.html and newpage.html and we invoke
#	&backupMove("newpage.html", "page.html");
# we get page.html~ and page.html.
sub backupMove {
    my $frompage = $_[0];
    my $topage = $_[1];
    my $backuppage = "$topage~";

    # backup the existing page
    if (-e $topage) {
	unlink($backuppage);
	link($topage, $backuppage)
	    || print STDERR "Warning: cannot create backup page $backuppage\n";
	unlink($topage)
	    || print STDERR "Warning: cannot unlink page $topage\n";
    }

    # rename the temporary file
    link($frompage, $topage)
	|| die("Cannot link temporary file $frompage to $topage, stopped");
    unlink($frompage);
}

# "quote" characters which are special in regular expression patterns
sub quoteREpatterns ($) {
    my $expr = shift;

    $expr =~ s|\\|\\\\|g;
    $expr =~ s/\|/\\\|/g;
    $expr =~ s|\(|\\(|g;
    $expr =~ s|\)|\\)|g;
    $expr =~ s|\[|\\[|g;
    $expr =~ s|\{|\\{|g;
    $expr =~ s|\^|\\^|g;
    $expr =~ s|\$|\\\$|g;
    $expr =~ s|\*|\\*|g;
    $expr =~ s|\+|\\+|g;
    $expr =~ s|\?|\\?|g;
    $expr =~ s|\.|\\.|g;
    # we'll use / as separator, so it is special for us, too
    $expr =~ s|/|\\/|g;

    $expr;
}

# Rewrite any LaTeX expressions with those in latexRewrites
sub rewriteLatex ($) {
    if ($_[0] =~ /\$/) {
	# it has a dollar sign, so it is probably a LaTeX expression
	# print "Start : $_[0]\n";
	for $onesubs (@latexRewrites) {
	    #do {print "Before: $_[0]\n";}
	    1 while eval "\$_[0] =~ $onesubs";
	    # print "After : $_[0]\n";
	}

	# remove all $...$ brackets
	$_[0] =~ s/\$(.*?[^\\])\$/$1/g;
	# print "Final : $_[0]\n";
    }
}

#------------------------------------------------------------------------
#
# Step I: read initialization and config files
#
#------------------------------------------------------------------------

# Step Ia: read areas
open(AREASFH, "< $AREAS")
	|| die("Cannot open areas file, $AREAS\n");

while (<AREASFH>) {
    next if (/^ *\#/o); # skip comment lines
    chop;

    # get abbreviation and print name
    local ($abbrev, $areaPrintName) = split /\t+/;
    $areas{$abbrev} = $areaPrintName;
}

close AREASFH;

# Step Ib: read types
open(TYPESFH, "< $TYPES")
	|| die("Cannot open types file, $TYPES\n");

while (<TYPESFH>) {
    next if (/^ *\#/o); # skip comment lines
    chop;

    # get abbreviation and print name
    local ($abbrev, $areaPrintName) = split /\t+/;
    $types{$abbrev} = $areaPrintName;
}

close TYPESFH;

# Step Ic: read authors and their initials
open(AUTHRS, "< $AUTHORS")
	|| die("Cannot open authors file, $AUTHORS\n");

while (<AUTHRS>) {
    next if (/^ *\#/o);
    # get initials ($1), name ($2), and optional e-mail, url, etc. ($3)
    /^([^\t]*)\t([^\t]*)\t?(.*)?/o;
    $authors{$1} = $2;
    $authemail{$1} = $3;
}

close AUTHRS;

# Step Id: read LaTeX rewrite expressions
open(REWRTS, "< $LATEXREWRITES")
	|| die("Cannot open LaTeX rewrites file, $LATEXREWRITES\n");

while (<REWRTS>) {
    my ($pat, $replace);
    next if /^\s*\#/o || /^\s*$/o; # skip comment and blank lines
    SWITCH: {
	if (/^(\S*\{.*)\$(.*\}\S*\{.*)\$(\S*\})\s+(.*)\$(.*)\$(.*)/o) {
	    # replace $...$lpat{$mid1}$cpat{$mid2}$rpat...$
	    # with    $...$lrepl$mid1$crepl$mid2$rrepl...$
	    my ($leftpat, $centerpat, $rightpat,
				$leftreplace, $centerreplace, $rightreplace);
	    $leftpat  = quoteREpatterns($1);
	    $centerpat= quoteREpatterns($2);
	    $rightpat = quoteREpatterns($3);
	    $pat = "$leftpat(.*?)$centerpat(.*?)$rightpat";
	    $leftreplace  = quoteREpatterns($4);
	    $centerreplace= quoteREpatterns($5);
	    $rightreplace = quoteREpatterns($6);
	    $replace = " $leftreplace\$2$centerreplace\$3$rightreplace";
	    # print "REPLACE $pat\n";
	    # print "with    $replace\n";
	    last SWITCH;
	}
	if (/^(\S*\{.*)\$(\S*\})\s+(.*)\$(.*)/o) {
	    # replace $...$lpat{$mid$rpat}...$
	    # with    $...$lrepl$mid$rrepl...$
	    my ($leftpat, $rightpat, $leftreplace, $rightreplace);
	    $leftpat  = quoteREpatterns($1);
	    $rightpat = quoteREpatterns($2);
	    $pat = "$leftpat(.*?)$rightpat";
	    $leftreplace  = quoteREpatterns($3);
	    $rightreplace = quoteREpatterns($4);
	    $replace = " $leftreplace\$2$rightreplace";
	    # print "REPLACE $pat\n";
	    # print "with    $replace\n";
	    last SWITCH;
	}
	if (/^(\S*\{.*)\$(\S*\})\s+(.*)/o) {
	    # replace $...$lpat{$mid$rpat}...$
	    # with    $...$replace...$
	    my ($leftpat, $rightpat);
	    $leftpat  = quoteREpatterns($1);
	    $rightpat = quoteREpatterns($2);
	    $pat = "$leftpat(.*?)$rightpat";
	    $replace  = quoteREpatterns($3);
	    $replace = " $replace";
	    # print "REPLACE $pat\n";
	    # print "with    $replace\n";
	    last SWITCH;
	}
	if (/^(\S+)\s*(.*)/o) {
	    $pat = quoteREpatterns($1);
	    $replace = $2;
	    if (!($replace eq '"' || $replace eq ')' || $replace eq '}')) {
		# pad everything but left-closers with a space so things
		# like $s\in T$ look right
		# HTML compresses spaces, so $s \in T$ looks right, too
		$replace = " $replace";
	    }
	    $replace = quoteREpatterns($replace);
	    last SWITCH;
	}
	{
	    print "latex rewrite line ignored: $_";
	    next;
	}
    }
	
    # rewrite as a substitution within $'s
    # this means: replace $...$pat...$ with $...$replace...$
    push @latexRewrites,
		"s/(\\\$[^\\\$]*)$pat(?=.*?\\\$)/\$1$replace/g";
    # print "full: $latexRewrites[-1]\n";
}

close REWRTS;


#------------------------------------------------------------------------
#
# Step II: read term entries
#
#------------------------------------------------------------------------

print STDERR "Reading terms" if ($verbose);

# Step IIa: get a list of all term entry files
@entries=`ls $TERMS_DIR/[A-Za-z]*.$TERM_EXT`;

#print @entries;

# count the number of entries read
$numEntriesRead = 0;

# Step IIb: read each entry file and save the properties
while ($entryFile = shift @entries) {
    undef %thisEntry; # make sure nothing is left over
    my($thisEntry) = {};

    chop $entryFile;

    open(ENTRY, "< $entryFile")
	|| print STDERR "Cannot open $entryFile\n" && next;

    while (<ENTRY>) {
	if (/modified "([^"]+)"/) {
	    $thisEntry{MODIFIED} = $1;
	}

	next if (/^ *\#/o); # skip comments

	# look for property headers
	if (s/^@([^=]*)=//o) {
	    $prop=$1;
	}
	chop;
	next if /^$/; # ignore empty lines
	if (! defined $properties{$prop}) {
	    print "Unknown property $prop in $entryFile\n";
	}
	if (defined $thisEntry{$prop}) {
	    $thisEntry{$prop} .= " "; # space after existing stuff
	}
	$thisEntry{$prop} .= $_; # save the info
    }

    close ENTRY;

    $numEntriesRead++;

    # save the base of the file name (to create a parallel HTML page)
    ($thisEntry{BASEFILENM}) = ($entryFile =~ m|.*/([^.]*)|o);

    # if no NAME given, make one from the file name
    if (! defined $thisEntry{NAME}) {
	print "No entry NAME given in $entryFile\n";
	# assign a default
	($thisEntry{NAME}) = ($thisEntry{BASEFILENM});
    } else {
	if ($thisEntry{NAME} =~ / $/) {
	    print "NAME <<$thisEntry{NAME}>> has a trailing blank in $entryFile\n";
	}
    }

    # audit the entry
    if (defined $thisEntry{TYPE}) {
	my($etype) = $thisEntry{TYPE};
	if (! defined $types{$etype}) {
	    print "Unknown TYPE $etype in $entryFile\n";
	}
    }
    if (defined $thisEntry{AREA}) {
	my($earea) = $thisEntry{AREA};
	if (! defined $areas{$earea}) {
	    print "Unknown AREA $earea in $entryFile\n";
	}
    }
    if (defined $thisEntry{AUTHOR}) {
	foreach $initials (split / *, */, $thisEntry{AUTHOR}) {
	    if (! defined $authors{$initials}) {
		print "Unknown AUTHOR $initials in $entryFile\n";
	    }
	}
    }

    # NAME (ename in other places) is original name, e.g.,
    #		BB$\alpha<sub>2</sub>$ tree
    # XNAME is name without LaTeX markers to lookup cross references.
    #		BB\alpha<sub>2</sub> tree
    # DNAME is display name, e.g.,
    #		BB<src img="alpha.gif"><sub>2</sub> tree
    # TNAME is plain-text name, e.g., without HTML or LaTeX markers.
    #		BBalpha2 tree
    # ename HERE is name used to alphabetize, e.g.,
    #		BBALPHATWOTREE

    # save a version of the entry name without LaTeX markers for lookup
    ($thisEntry{XNAME} = $thisEntry{NAME}) =~ s/\$([^\$]*)\$/$1/go;

    # save a rich display version of the entry name
    rewriteLatex($thisEntry{DNAME} = $thisEntry{NAME});

    # save a plain text version of the entry name, i.e., without HTML
    ($tname = $thisEntry{NAME}) =~ s/<[^>]*>//go;
    $tname =~ s/\$([^\$]*)\$/$1/go;
    $tname =~ s/\\//go;
    ($thisEntry{TNAME}) = $tname;

    # add this to an "index" for later sorting and printing
    my $ename = $thisEntry{NAME};
    print STDERR "." if ($verbose); # progress indicator
    # index some numbers and symbols as words
    $ename =~ s/\b0\b/zero/g;
    $ename =~ s/\b1\b/one/g;
    $ename =~ s/\b2\b/two/g;
    $ename =~ s/\b3\b/three/g;
    $ename =~ s/\b4\b/four/g;
    $ename =~ s/[*]/star/go;
    $ename =~ s/[+]/plus/go;
    # remove any embedded html
    $ename =~ s/<[^>]*>//go;
    $startsWithSpecial = ($ename =~ /^\$\\/);
    # make all letters upper case and remove any remaining non-letter
    $ename =~ tr/A-Za-z\0-\377/A-ZA-Z/d;
    if ($startsWithSpecial) {
	# prepend a space so names with special characters come first
	$ename = " $ename";
    }
    # make sure entry name is unique
    while (defined $entries{$ename}) {
	$ename .= "Z";
    }
    # save as a hash-of-hashes
    for $fld (keys %thisEntry) {
	$entries{$ename}{$fld} = $thisEntry{$fld};
    }

    #print "NAME is $thisEntry{NAME}\nTNAME is $thisEntry{TNAME}\n";
    #print "DNAME is $thisEntry{DNAME}\nename is $ename\n";
    #print "XNAME is $thisEntry{XNAME}\n";
    # remember this entry to check cross references
    $entriesForXref{$thisEntry{XNAME}} = $ename;
}
print STDERR "\n" if ($verbose);

print "Read $numEntriesRead terms\n";

#------------------------------------------------------------------------
#
# Step III: create the main and two-level web pages in temporary files
#	a) create a temporary file for the main (combined) index
#		copy the introduction
#	b) create a temporary file for the two-level index
#		and copy the introduction
#
#------------------------------------------------------------------------

# Step IIIa: create a temporary file for the main index and copy the intro
$pagename="$WEBPAGE.html";
$temppage="$WEB_DIR/\#$WEBPAGE.html";

unlink($temppage) if (-e $temppage);
open(TMPPAGE, "> $temppage")
    || die ("Cannot create temporary web page $temppage, stopped");

&concatenate("$WEBPAGE.intro", TMPPAGE);

# write processing date and time
#print TMPPAGE "<P>\nRun on $now\n";

# (FF) Add an alphabetical index for fast access
print TMPPAGE "\n<h3>";
foreach $letter ("A".."Z") {
    print TMPPAGE "<a href=\"\#$letter\">$letter</a>\n";
}
print TMPPAGE "</h3>\n";


# Step IIIb: create a temporary file for the two-level index and copy the intro
$twolevpage="$TWOLEVEL.html";
$twolevtemp="$WEB_DIR/\#$TWOLEVEL.html";

unlink($twolevtemp) if (-e $twolevtemp);
open(TMP2LEV, "> $twolevtemp")
    || die ("Cannot create temporary web page $twolevtemp, stopped");

&concatenate("$TWOLEVEL.intro", TMP2LEV);


#------------------------------------------------------------------------
#
# Step IIIc: write each entry to its own page, in main page index, 
# and in the two-level index
#
#------------------------------------------------------------------------

sub rewriteXrefs {
    # rewrite cross references ({...}) as href's (to entries, not files)
    #print "STEP 1: $_[0] \n"; # for debugging
    $_[0] =~ s|%|%P|go; # preserve our escape character
    $_[0] =~ s|\\{|%R|go; # escape {'s in HTML markup
    #print "STEP 3: $_[0] \n"; # for debugging
    # rewrite complex references ( {text#xref} ) first
    $_[0] =~ s|{([^}]+)\#([^}]+)}|<a href="\#$2"><em>$1</em></a>|go;
    # now rewrite simple references ( {textref} )
    $_[0] =~ s|{(.+?)}|<a href="\#$1"><em>$1</em></a>|go;
    # change escaped characters back
    $_[0] =~ s|%R|{|go; # unescape {'s for final display
    $_[0] =~ s|%P|%|go;
    #print "STEP 7: $_[0] \n"; # for debugging

    # change entry names to their corresponding files and
    #   report any dangling xrefs
    foreach $xref (split /^.*?href="\#|".*?href="\#|".*?$|^.*$/, $_[0]) {
	next if ($xref eq ""); # above RE starts with a null split
	#print "\nFound $xref\n"; # for debugging
	my $strippedXref = $xref;
	$strippedXref =~ s/\$([^\$]*)\$/$1/go; # strip LaTeX markers
	my $indexXref = $strippedXref;
	if (! defined $entriesForXref{$indexXref}) {
	    # try the singular, i.e., removing a trailing "s"
	    $indexXref =~ s/s$//;
	    if (! defined $entriesForXref{$indexXref}) {
		# try removing a trailing "es"
		$indexXref = $strippedXref; # start again
		$indexXref =~ s/es$//;
		if (! defined $entriesForXref{$indexXref}) {
		    print "\n    *****Unknown HyperREFerence to \"$xref\" in $_[1]\n";
		    next;
		}
	    }
	}

	my $xrefKey = $entriesForXref{$indexXref};
	#print "\nit is $xrefKey\n";
	%xrefEntry = %{$entries{$xrefKey}};
	my($xrefFile) = "$xrefEntry{BASEFILENM}.html";

	# quote special RE characters
	my $xrefQ = quoteREpatterns("\#$xref");

	#print "subs is /$xrefQ/$xrefFile/\n"; # for debugging
	$_[0] =~ s/$xrefQ/$xrefFile/;
    }
}

# Rewrite external HREFs to use the NIST "exit script" described at
#	http://webservices.nist.gov/exit_nist.htm
sub rewriteHrefs {
    foreach $xref (split /^.*?href="|".*?href="|".*?$|^.*$/i, $_[0]) {
	next if ($xref eq ""); # above RE starts with a null split
	next if $xref =~ /nist\.gov/; # don't rewrite internal links
	#print "\nFound $xref\n"; # for debugging

	# quote special cgi characters
	my($xrefCGIQ) = $xref;
	$xrefCGIQ =~ s|%|%25|g;
	$xrefCGIQ =~ s| |%20|g;
	$xrefCGIQ =~ s|"|%22|g;
	$xrefCGIQ =~ s|\#|%23|g;
	$xrefCGIQ =~ s|&|%26|g;
	$xrefCGIQ =~ s|\+|%2B|g;
	#$xrefCGIQ =~ s|/|%2F|g;
	$xrefCGIQ =~ s|;|%3B|g;
	$xrefCGIQ =~ s|=|%3D|g;
	$xrefCGIQ =~ s|~|%7E|g;
	my($xrefExit) = "\"http://www.nist.gov/cgi-bin/exit_nist.cgi?url=$xrefCGIQ\"";

	# quote special RE characters
	my $xrefQ = quoteREpatterns("\"$xref\"");

	#print "subs is /$xrefQ/$xrefExit/\n"; # for debugging
	$_[0] =~ s/$xrefQ/$xrefExit/;
    }
}

print STDERR "Writing terms\n" if ($verbose);

# find the age of the younger of the entry intro and entry conclusion 
# files, so we can check whether we need to rewrite the HTML page.
$ENTNEWESTMOD = -M $ENTCONCL;
if (-M $ENTINTRO < $ENTNEWESTMOD) {
    $ENTNEWESTMOD = -M $ENTINTRO;
}

################################################
# start a two columns table
################################################
print TMPPAGE << "TABLE_BEGINNING";
<TABLE BORDER=0 WIDTH="100%">
<TR>
<TD valign=top>
TABLE_BEGINNING

# start with special characters
$letter = " ";
print TMPPAGE "<dl>\n";

################################################
# start the two-level index
################################################
print TMP2LEV << "TWO_LEVEL_BEGINNING";
<UL>
TWO_LEVEL_BEGINNING
$optimEntriesPerPage = 1.3 * sqrt $numEntriesRead;
$entriesInPage = 0; # how many entries written in this page?
$indexPageName = "t00";

$prevdname = ""; # check for repeated entries

# sort the entries
@sortedentries = sort keys %entries;
#print @sortedentries;
$numEntries = 0;

# Step IIIc: write the entries
for $ekey (@sortedentries) {
    %thisEntry = %{$entries{$ekey}};
    #print %thisEntry; print "\n";

    my($ename) = $thisEntry{NAME};
    my($tname) = $thisEntry{TNAME};
    my $dname = $thisEntry{DNAME};
    my $xname = $thisEntry{XNAME};
    if (defined $thisEntry{MODIFIED}) {
	$moddate = $thisEntry{MODIFIED};
    } else {
	$moddate = "sometime";
    }

    # check for repeated entry names.  This happens when I change the
    # file name for an entry, but forget to remove the old file.
    if ($dname eq $prevdname) {
	print "\n    *****Repeated entry: $dname\n";
    }
    $prevdname = $dname;

    $termpage="$OUT_DIR/$thisEntry{BASEFILENM}.html";
    $termurl ="$URL_DIR/$termpage";
    $termfile="$WEB_DIR/$termpage";

    $numEntries++;

    ###########################################################
    # Write an entry in the combined index page
    ###########################################################

    while (substr($ekey, 0, 1) gt $letter) {
	# finish previous letter
	print TMPPAGE "</dl>\n\n";

	# start new letter
	if ($letter eq " ") {
	    $letter = "A";
	} else {
	    $letter++;
	}
	if ($letter eq "M") {
	    # start new column
	    print TMPPAGE << "TABLE_NEXT_COLUMN";
</td>

<td valign=top>
TABLE_NEXT_COLUMN
	}
	print TMPPAGE "<a name=\"$letter\"><h2>$letter</h2>\n\n<dl>\n";
    }

    # write an entry in the main page
    print TMPPAGE "<dt><a href=\"$termpage\">$dname</a>";
    print TMPPAGE "\n";

    ###########################################################
    # Write an entry in the two-level index
    ###########################################################

    if ($entriesInPage == 0) {
	# start a new index page
	$indexPageName++;

	# SKIMP start new index page

	print TMP2LEV "<li><a href=\"$indexPageName.html\">$dname - ";
    }
    $entriesInPage++;
    if ($entriesInPage > $optimEntriesPerPage) {
	# finish the current index page

	# SKIMP finish the current index page

	print TMP2LEV "$dname</a>\n";

	$entriesInPage = 0;
    }

    ###########################################################
    # Write the entry HTML page (if necessary)
    ###########################################################

    # should we write the HTML page?
    if ((! -e $termfile) || $writeAllPages
	|| (-C $termfile > -M "$TERMS_DIR/$thisEntry{BASEFILENM}.trm")
	|| (-C $termfile > $ENTNEWESTMOD)) {
	# write the page
	print STDERR "$tname, " if ($verbose);
    } else {
	# don't need to write the page
	print STDERR ", " if ($verbose); # just a "working" mark
	next;
    }

    unlink($termfile) if (-e $termfile);
    open(TERMPAGE, "> $termfile")
	|| die ("Cannot create term web page $termfile, stopped");

    # copy term page intro, replacing variables as appropriate
    open(FHANDLE, "< $ENTINTRO")
	|| die("Cannot open $ENTINTRO\n");
    $runtime = localtime;
    while (<FHANDLE>) {
	s/\$NAME/$ename/g;
	s/\$DNAME/$dname/g;
	s/\$TNAME/$tname/g;
	s/\$RUNDATE/$runtime/g;
	s/\$MODDATE/$moddate/g;
	s/\$URL/$termurl/g;
	print TERMPAGE $_;
    };
    close(FHANDLE);

    if (defined $thisEntry{TYPE}) {
	my($etype) = $thisEntry{TYPE};
	my($elongtype) = $types{$etype};
	$elongtype =~ tr/A-Z/a-z/; # make lower case
	$elongtype =~ s/s$//o; # make singluar (not plural)
	print TERMPAGE "<P>\n($elongtype)\n\n";
    }
    print TERMPAGE "<P>\n<strong>Definition:</strong>\n";
    if (defined $thisEntry{DEFN}) {
	my($edefn) = $thisEntry{DEFN};
	# convert cross references ({...}) to href's
	&rewriteXrefs($edefn, $ename);
	# convert LaTeX expressions to HTML
	&rewriteLatex($edefn);
	print TERMPAGE "$edefn\n";
    } else {
	print TERMPAGE << "NO_DEFN_MESSAGE";
(no definition here, yet, but
<A HREF=\"../$pagename\#needHelp\">you can help</A>.)
NO_DEFN_MESSAGE
    }
    if (defined $thisEntry{AKA}) {
	my($ealiases) = $thisEntry{AKA};
	# have exactly one space after a comma
	$ealiases =~ s|,\s*|, |go;
	print TERMPAGE "<P><strong>Also known as</strong> $ealiases.\n";
    }
    if (defined $thisEntry{XREFS}) {
	my($exrefs) = $thisEntry{XREFS};
	# change cross references ({...}) to href's
	&rewriteXrefs($exrefs, $ename);
	# convert LaTeX expressions to HTML
	&rewriteLatex($exrefs);
	# have exactly one space after a comma
	$exrefs =~ s|,\s*|, |go;
	print TERMPAGE "<P><strong>See also</strong>\n$exrefs.\n";
    }
    if (defined $thisEntry{NOTES}) {
	my($enotes) = $thisEntry{NOTES};
	# convert cross references ({...}) to href's
	&rewriteXrefs($enotes, $ename);
	# convert LaTeX expressions to HTML
	&rewriteLatex($enotes);
	print TERMPAGE "<P><em>Note:\n$enotes</em>\n";
    }
    if (defined $thisEntry{AUTHOR}) {
	my($eauth) = $thisEntry{AUTHOR};
	$eauth =~ s| *([^,]+)|<a href="../$pagename\#author$1">$1</a>|go;
	# SKIMP write plural if more than one
	print TERMPAGE "<P>Author: $eauth\n";
    }
    if (defined $thisEntry{IMPL}) {
	my($eimpls) = $thisEntry{IMPL};
	# rewrite HREFs with exit_nist script
	&rewriteHrefs($eimpls);
	# SKIMP write plural if more than one
	print TERMPAGE "<H2>Implementation</H2>\n$eimpls\n";
    }
    if (defined $thisEntry{LINKS} || defined $thisEntry{BIB}) {
	print TERMPAGE "<H2>More information</H2>\n";
    }
    if (defined $thisEntry{LINKS}) {
	my($elinks) = $thisEntry{LINKS};
	# rewrite HREFs with exit_nist script
	&rewriteHrefs($elinks);
	print TERMPAGE "$elinks\n";
    }
    if (defined $thisEntry{BIB}) {
	my($ebiblio) = $thisEntry{BIB};
	print TERMPAGE "<p>\n$ebiblio\n</p>\n";
    }
    print TERMPAGE "\n";

    # copy term page conclusion, replacing variables as appropriate
    open(FHANDLE, "< $ENTCONCL")
	|| die("Cannot open $ENTCONCL\n");
    while (<FHANDLE>) {
	s/\$NAME/$ename/g;
	s/\$DNAME/$dname/g;
	s/\$TNAME/$tname/g;
	s/\$RUNDATE/$runtime/g;
	s/\$MODDATE/$moddate/g;
	s/\$URL/$termurl/g;
	print TERMPAGE $_;
    };
    close(FHANDLE);

    close(TERMPAGE);
}

# print any remaining letters, for completeness
while ("Z" gt $letter) {
    # finish previous letter
    print TMPPAGE "</dl>\n\n";

    # start new letter
    $letter++;
    print TMPPAGE "<h2><a name=\"$letter\">$letter</a></h2>\n\n<dl>\n";
}

# finish last letter
print TMPPAGE "</dl>\n\n"; # end of list and section

# finish two column table
print TMPPAGE << "TABLE_ENDING";
</td>
</tr>
</table>
TABLE_ENDING

print STDERR "\n" if ($verbose);

print "Wrote $numEntries terms\n";

#------------------------------------------------------------------------
#
# Step IIId,e: write authors and copy closing
#
#------------------------------------------------------------------------

# Step IIId: write authors

print STDERR "Writing authors\n" if ($verbose);

print TMPPAGE "<hr>\n";
print TMPPAGE "<h1>Contributors Index</h1>\n";
print TMPPAGE "<dl>\n";

for $akey (sort keys %authors) {
    print TMPPAGE "<dt><a name=\"author$akey\">$akey</a>\n";
    my $aentry = $authors{$akey};
    # "quote" any HTML special characters
    $aentry =~ s/&/&amp;/go;
    $aentry =~ s/</&lt;/go;
    $aentry =~ s/>/&gt;/go;
    print TMPPAGE "<dd>$aentry\n";
    # print e-mail address(es) or URL(s), if given
    if (defined $authemail{$akey}) {
	for $fld (split(/, */, $authemail{$akey})) {
	    if ($fld =~ /@/) {
		# e-mail
		print TMPPAGE "<a href=\"mailto:$fld\">$fld</a>\n";
	    } else {
		# URL
		print TMPPAGE "<a href=\"$fld\">$fld</a>\n";
	    }
	}
    }
}

print TMPPAGE "</dl>\n\n";

# Step IIIe: copy the closing
&concatenate("$WEBPAGE.concl", TMPPAGE);

close TMPPAGE;

# Step IIIf: backup old page and rename the temporary file

&backupMove($temppage, "$WEB_DIR/$pagename") if ! $justTesting;

#------------------------------------------------------------------------
#
# Step IV: copy closing of two-level index, backup old page, and
# rename temporary file
#
#------------------------------------------------------------------------

# if the index page isn't finished, do it now
if ($entriesInPage > 0) {
    # finish the current index page

    # SKIMP finish the current index page

    print TMP2LEV "$prevdname</a>\n";
}

print TMP2LEV "</UL>\n\n";

&concatenate("$TWOLEVEL.concl", TMP2LEV);

close TMP2LEV;

&backupMove($twolevtemp, "$WEB_DIR/$twolevpage") if ! $justTesting;

#------------------------------------------------------------------------
#
# Step V: write entries with implementations
#
#------------------------------------------------------------------------

# Step Va: select name and open the page

$pageroot="$WEBPAGE" . "Impl";
$fspagename="$WEB_DIR/$pageroot.html";
$temppage="$WEB_DIR/\#$pageroot.html";

unlink($temppage) if (-e $temppage);
open(TMPPAGE, "> $temppage")
    || die ("Cannot create temporary web page $temppage, stopped");

# Step Vb: copy the intro
&concatenate("$pageroot.intro", TMPPAGE);

# write processing date and time
print TMPPAGE "<P>\nRun on $now\n";

# Step Vc: write entries with implementations

print STDERR "Writing entries with implementation links\n" if ($verbose);

print TMPPAGE "<hr>\n";

print TMPPAGE "<ul>\n";

# go through all the entries and print those with implementations
for $ent (@sortedentries) {
    next if ! defined $entries{$ent}{IMPL};
    my $dname = $entries{$ent}{DNAME};
    my $eimpls = $entries{$ent}{IMPL};
    my $erelurl = "$OUT_DIR/$entries{$ent}{BASEFILENM}.html";
    print TMPPAGE "<li><a href=\"$erelurl\">$dname</a>: $eimpls\n";
}
print TMPPAGE "</ul>\n\n";

# Step Vd: copy the conclusion and close
&concatenate("$pageroot.concl", TMPPAGE);

close TMPPAGE;

# Step Ve: backup page and relink

&backupMove($temppage, $fspagename);

#------------------------------------------------------------------------
#
# Step VI: write area index page
#
#------------------------------------------------------------------------

print STDERR "Writing entries by area\n" if ($verbose);

# Step VIa: select name and open the page

$pageroot="$WEBPAGE" . "Area";
$fspagename="$WEB_DIR/$pageroot.html";
$temppage="$WEB_DIR/\#$pageroot.html";

unlink($temppage) if (-e $temppage);
open(TMPPAGE, "> $temppage")
    || die ("Cannot create temporary web page $temppage, stopped");

# Step VIb: copy the intro
&concatenate("$pageroot.intro", TMPPAGE);

# write processing date and time
print TMPPAGE "<P>\nRun on $now\n";

# Add links to each area for fast access
print TMPPAGE "\n<h3>Areas</h3>\n<ul>\n";
for $area (sort keys %areas) {
    print TMPPAGE "<li><a href=\"\#$area\">$areas{$area}</a>\n";
}
# add link to no area
print TMPPAGE "<li><a href=\"\#noarea\">Entries with No Area</a>\n";
print TMPPAGE "</ul>\n";

# Step VIc: write areas and entries

print TMPPAGE "<hr>\n";

sub printAreaEntry {
    my %thisEntry = %{$entries{$_[0]}};
    my $dname = $thisEntry{DNAME};
    my $erelurl = "$OUT_DIR/$thisEntry{BASEFILENM}.html";
    print TMPPAGE "<li><a href=\"$erelurl\">$dname</a>";
    if (defined $thisEntry{TYPE}) {
	my $etype = $thisEntry{TYPE};
	print TMPPAGE " [<strong>$etype</strong>]";
    }
    print TMPPAGE "\n";
}

for $area (sort keys %areas) {
    print TMPPAGE "<h2><a name=\"$area\">$areas{$area}</a></h2>\n";
    print TMPPAGE "<ul>\n";

    # go through all the entries and print those in this area
    for $ent (@sortedentries) {
	next if ! defined $entries{$ent}{AREA} ||
			$entries{$ent}{AREA} ne $area;
	&printAreaEntry($ent);
    }
    print TMPPAGE "</ul>\n\n";
}

# print any entries without an area
print TMPPAGE "<h2><a name=\"noarea\">Entries with No Area</a></h2>\n";
print TMPPAGE "<ul>\n";
for $ent (@sortedentries) {
    if (! defined $entries{$ent}{AREA}) {
	&printAreaEntry($ent);
    }
}
print TMPPAGE "</ul>\n\n";

# Step VId: copy the conclusion and close
&concatenate("$pageroot.concl", TMPPAGE);

close TMPPAGE;

# Step VIe: backup page and relink

&backupMove($temppage, $fspagename);

#------------------------------------------------------------------------
#
# Step VII: write type index page
#
#------------------------------------------------------------------------

print STDERR "Writing entries by type\n" if ($verbose);

# Step VIIa: select name and open the page

$pageroot="$WEBPAGE" . "Type";
$fspagename="$WEB_DIR/$pageroot.html";
$temppage="$WEB_DIR/\#$pageroot.html";

unlink($temppage) if (-e $temppage);
open(TMPPAGE, "> $temppage")
    || die ("Cannot create temporary web page $temppage, stopped");

# Step VIIb: copy the intro
&concatenate("$pageroot.intro", TMPPAGE);

# write processing date and time
print TMPPAGE "<P>\nRun on $now\n";

# Add links to each section for fast access
print TMPPAGE "\n<h3>Types</h3>\n<ul>\n";
for $tent (keys %types) {
    print TMPPAGE "<li><a href=\"\#$tent\">$types{$tent}</a>\n";
}
# add link to unclassified entries
print TMPPAGE "<li><a href=\"\#notype\">Entries with No Type</a>\n";
print TMPPAGE "</ul>\n";

# Step VIIc: write types and entries

print TMPPAGE "<hr>\n";

for $tent (keys %types) {
    print TMPPAGE "<h2><a name=\"$tent\">$types{$tent}</a></h2>\n";
    print TMPPAGE "<ul>\n";

    # go through all the entries and print those of this type
    for $ent (@sortedentries) {
	next if ! defined $entries{$ent}{TYPE} ||
			$entries{$ent}{TYPE} ne $tent;
	my $dname = $entries{$ent}{DNAME};
	my $erelurl = "$OUT_DIR/$entries{$ent}{BASEFILENM}.html";
	print TMPPAGE "<li><a href=\"$erelurl\">$dname</a>\n";
    }
    print TMPPAGE "</ul>\n\n";
}

# print those with no type
print TMPPAGE "<h2><a name=\"notype\">Entries with No Type</a></h2>\n";
print TMPPAGE "<ul>\n";
for $ent (@sortedentries) {
    if (! defined $entries{$ent}{TYPE}) {
	my $dname = $entries{$ent}{DNAME};
	my $erelurl = "$OUT_DIR/$entries{$ent}{BASEFILENM}.html";
	print TMPPAGE "<li><a href=\"$erelurl\">$dname</a>\n";
    }
}
print TMPPAGE "</ul>\n\n";

# Step VIId: copy the conclusion and close
&concatenate("$pageroot.concl", TMPPAGE);

close TMPPAGE;

# Step VIIe: backup page and relink

&backupMove($temppage, $fspagename);

exit;

# end of $Source: /home/black/DADS/dads/RCS/mkterms,v $
