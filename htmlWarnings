UNDERSCORE
<strong>Omer H. Abu El Haija</strong> and <strong>Azmi Alazzam</strong>,  <em>Bond-Sequential Search (BSS)</em>, Proc. World Congress on Engineering and Computer Science (WCECS) 2012, Vol I, San Francisco, California, USA, October 2012. <a href="http://www.iaeng.org/publication/WCECS2012/WCECS2012_pp194-198.pdf" target="_blank">http://www.iaeng.org/publication/WCECS2012/WCECS2012_pp194-198.pdf<a/> accessed 9 June 2016. in BondSeqSearch.html
BACKSLASH, CARET, or DOLLAR SIGN
<p> Here is pseudocode for an inefficient Cupif-Giannini tree traversal with Xor "randomization" (** is the power operator, and ^ is xor):  in CupifGianniniTreeTraversal.html
UNDERSCORE
             visitNode(tree.left_subtree, nodeNumber, bitNumber+1);<br /> in CupifGianniniTreeTraversal.html
UNDERSCORE
             visitNode(tree.right_subtree, nodeNumber, bitNumber+1);<br /> in CupifGianniniTreeTraversal.html
BACKSLASH, CARET, or DOLLAR SIGN
         visitNode(tree, n ^ key, 1);<br /> in CupifGianniniTreeTraversal.html
UNDERSCORE
<a href="https://en.wikipedia.org/wiki/Merkle_tree" target="_blank"><em>Merkle_tree [Wikipedia]</em></a>. in MerkleTree.html
UNDERSCORE
 <strong>Ralph C. Merkle</strong>, <em>A Digital Signature Based on a Conventional Encryption Function</em>, in C. Pomerance (ed) Advances in Cryptology &mdash; CRYPTO &rsquo;87. Lecture Notes in Computer Science 293:369-378, 1988. <a href="https://doi.org/10.1007/3-540-48184-2_32" target="_blank">doi:10.1007/3-540-48184-2_32</a> in MerkleTree.html
UNDERSCORE
Contributed by Arvind &lt;uk_arvind@mail.utexas.edu&gt; May 2002.</em> in baumWelch.html
UNDERSCORE
<p> <a href="../terms.html#Knuth97">[Knuth97, 1:107]</a>,  <a href="../terms.html#HS83">[HS83, page 31]</a>, and <a href="../terms.html#Stand98">[Stand98, page 466]</a> use |f(n)| &le; c|g(n)|.   In <a href="https://en.wikipedia.org/wiki/Computational_complexity_theory" target="_blank"><em>Computational_complexity_theory [Wikipedia]</em></a> "only positive functions are considered, so the absolute value bars may be left out." (Wikipedia, "Big O notation"). This definition after <a href="../terms.html#CLR90">[CLR90, page 26]</a>. </p>  in bigOnotation.html
BACKSLASH, CARET, or DOLLAR SIGN
                 /|\          <br /> in binaryTreeRepofTree.html
BACKSLASH, CARET, or DOLLAR SIGN
                / | \         <br /> in binaryTreeRepofTree.html
BACKSLASH, CARET, or DOLLAR SIGN
               /  |  \        <br /> in binaryTreeRepofTree.html
BACKSLASH, CARET, or DOLLAR SIGN
             / \      |       <br /> in binaryTreeRepofTree.html
BACKSLASH, CARET, or DOLLAR SIGN
                     / \      <br /> in binaryTreeRepofTree.html
BACKSLASH, CARET, or DOLLAR SIGN
             / \              <br /> in binaryTreeRepofTree.html
BACKSLASH, CARET, or DOLLAR SIGN
             \   \            <br /> in binaryTreeRepofTree.html
BACKSLASH, CARET, or DOLLAR SIGN
               \              <br /> in binaryTreeRepofTree.html
UNDERSCORE
 <a href="https://en.wikipedia.org/wiki/Bloom_filter" target="_blank"><em>Bloom_filter [Wikipedia]</em></a> gives many variants and extensions. <a href="http://cap-lore.com/code/BloomTheory.html" target="_blank" target="_blank">Trade-offs and engineering techniques</a> with links to sites with recent papers, hash functions, etc. <a href="http://pages.cs.wisc.edu/~cao/papers/summary-cache/node8.html" target="_blank" target="_blank">Another explanation</a> typo: probability of false positive is missing a minus sign; exponent should be ... e<sup>-kn/m</sup>. <a href="https://www.perl.com/pub/2004/04/08/bloom_filters.html" target="_blank" target="_blank">Using Bloom filters</a>.  Language is Perl. Jason Davies'  <a href="https://www.jasondavies.com/bloomfilter/" target="_blank" target="_blank">interactive animation</a> helps people understand how a Bloom filter works. in bloomFilter.html
UNDERSCORE
 <strong>Prosenjit Bose, Hua Guo, Evangelos Kranakis, Anil Maheshwari, Pat Morin, Jason Morrison, Michiel Smid, and Yihui Tang</strong>, <em>On the False-Positive Rate of Bloom Filters</em>, Technical Report TR-07-07, Carleton University - School of Computer Science, 1 March 2007.  Available at http://www.scs.carleton.ca/research/tech_reports/index.php?Abstract=tr-07-07_0007 <br /> in bloomFilter.html
UNDERSCORE
<p> Contributed by Arvind &lt;uk_arvind@mail.utexas.edu&gt; May 2002.</em> in bradfordsLaw.html
BACKSLASH, CARET, or DOLLAR SIGN
  &nbsp; &nbsp; BWT[i] = T[SA[i]-1], if SA[i] &gt; 1, otherwise $ <br /> in burrowsWheelerTransform.html
BACKSLASH, CARET, or DOLLAR SIGN
 where T is the original string, i goes from 1 (<a href="oneBasedIndexing.html"><em>1-based indexing</em></a>) to the length of T, SA is the suffix array of T, and $ is the special character indicating the end of string.</em> in burrowsWheelerTransform.html
UNDERSCORE
<a href="https://en.wikipedia.org/wiki/Burrows-Wheeler_transform" target="_blank"><em>Burrows-Wheeler_transform [Wikipedia]</em></a>. in burrowsWheelerTransform.html
BACKSLASH, CARET, or DOLLAR SIGN
         printf("%d\n", head(l));<br /> in collectiveRecursion.html
UNDERSCORE
<pre>          ____________	<br /> in cubeRoot.html
BACKSLASH, CARET, or DOLLAR SIGN
        \/ 55,742,968.	<br /> in cubeRoot.html
UNDERSCORE
<pre>          __3_________	<br /> in cubeRoot.html
BACKSLASH, CARET, or DOLLAR SIGN
        \/ 55,742,968.	<br /> in cubeRoot.html
UNDERSCORE
<pre>          __3_________	<br /> in cubeRoot.html
BACKSLASH, CARET, or DOLLAR SIGN
        \/ 55,742,968.	<br /> in cubeRoot.html
UNDERSCORE
 </pre> Coming up with the next "divisor" is more involved than for  <a href="squareRoot.html"><em>square roots</em></a>.  First bring down 3 times the square of the number on top (3 &times; 3&sup2;=27) leaving room for two more digits (27_ _).  in cubeRoot.html
UNDERSCORE
<pre>          __3_________	<br /> in cubeRoot.html
BACKSLASH, CARET, or DOLLAR SIGN
        \/ 55,742,968.	<br /> in cubeRoot.html
UNDERSCORE
     27_ _) 28742	<br /> in cubeRoot.html
UNDERSCORE
<pre>          __3___9_____	<br /> in cubeRoot.html
BACKSLASH, CARET, or DOLLAR SIGN
        \/ 55,742,968.	<br /> in cubeRoot.html
UNDERSCORE
     27_ _) 28742	<br /> in cubeRoot.html
UNDERSCORE
<pre>          __3___9_____	<br /> in cubeRoot.html
BACKSLASH, CARET, or DOLLAR SIGN
        \/ 55,742,968.	<br /> in cubeRoot.html
UNDERSCORE
<pre>          __3___8_____	<br /> in cubeRoot.html
BACKSLASH, CARET, or DOLLAR SIGN
        \/ 55,742,968.	<br /> in cubeRoot.html
UNDERSCORE
     27_ _) 28742	<br /> in cubeRoot.html
UNDERSCORE
<pre>          __3___8_____	<br /> in cubeRoot.html
BACKSLASH, CARET, or DOLLAR SIGN
        \/ 55,742,968.	<br /> in cubeRoot.html
UNDERSCORE
<pre>          __3___8_____	<br /> in cubeRoot.html
BACKSLASH, CARET, or DOLLAR SIGN
        \/ 55,742,968.	<br /> in cubeRoot.html
UNDERSCORE
 </pre> We are ready to start over on the next digit.  Bring down the next three digits.  The divisor starts as 3 times the square of the number on top (3 &times; 38&sup2;=4332) leaving room for two more digits (4332_ _).  in cubeRoot.html
UNDERSCORE
<pre>          __3___8_____	<br /> in cubeRoot.html
BACKSLASH, CARET, or DOLLAR SIGN
        \/ 55,742,968.	<br /> in cubeRoot.html
UNDERSCORE
     4332_ _) 870968	<br /> in cubeRoot.html
UNDERSCORE
<pre>          __3___8___2_	<br /> in cubeRoot.html
BACKSLASH, CARET, or DOLLAR SIGN
        \/ 55,742,968.	<br /> in cubeRoot.html
UNDERSCORE
     4332_ _) 870968	<br /> in cubeRoot.html
UNDERSCORE
<pre>          __3___8___2_	<br /> in cubeRoot.html
BACKSLASH, CARET, or DOLLAR SIGN
        \/ 55,742,968.	<br /> in cubeRoot.html
UNDERSCORE
<pre>          __3___8___2_	<br /> in cubeRoot.html
BACKSLASH, CARET, or DOLLAR SIGN
        \/ 55,742,968.	<br /> in cubeRoot.html
UNDERSCORE
<p> Contributed by Arvind &lt;uk_arvind@mail.utexas.edu&gt; May 2002.</em> in cyclicRedundancyCheck.html
UNDERSCORE
<a href="https://en.wikipedia.org/wiki/Dense_graph" target="_blank"><em>Dense_graph [Wikipedia]</em></a> in densegraph.html
BACKSLASH, CARET, or DOLLAR SIGN
<pre> 	(1,0)^N = (F(N),F(N-1)) </pre> which can be computed in log N steps by <a href="repeatedSquaring.html"><em>repeated squaring</em></a>. </p>  in fibonacciNumber.html
BACKSLASH, CARET, or DOLLAR SIGN
<pre> 		       b^pow   pow	<br /> in fibonacciNumber.html
BACKSLASH, CARET, or DOLLAR SIGN
<pre> 	(1,1)(1,1) = (3,2)			b^2 * b^2 = b^4	<br /> in fibonacciNumber.html
BACKSLASH, CARET, or DOLLAR SIGN
 	(3,2)(3,2) = (9+6+6,9+4) = (21,13)	b^4 * b^4 = b^8	<br /> in fibonacciNumber.html
BACKSLASH, CARET, or DOLLAR SIGN
 	(1,1)(5,3) = (5+3+5,5+3) = (13,8)	b^2 * b^5 = b^7	<br /> in fibonacciNumber.html
UNDERSCORE
<a href="https://en.wikipedia.org/wiki/Self-organising_heuristic" target="_blank"><em>Self-organising_heuristic [Wikipedia]</em></a>. in frequencyCountHueristic.html
UNDERSCORE
<p> Thanks to Arvind &lt;uk_arvind@mail.utexas.edu&gt; May 2002. </p>  in hiddenMarkovModel.html
UNDERSCORE
     inorder(tree.left_subtree);<br /> in inorderTraversal.html
UNDERSCORE
     inorder(tree.right_subtree);<br /> in inorderTraversal.html
UNDERSCORE
Definition adapted from <a href="https://en.wikipedia.org/wiki/Inversion_list" target="_blank"><em>Inversion_list [Wikipedia]</em></a>.   More explanation and code in  <strong>Richard Gillam</strong>, <em> A Practical Programmer's Guide to the Encoding Standard</em>, chapter 13, page 504ff, Addison-Wesley Professional, 2002. in inversionList.html
UNDERSCORE
         levelorderAux(tree.left_subtree, level-1);<br /> in levelOrderTraversal.html
UNDERSCORE
         levelorderAux(tree.right_subtree, level-1);<br /> in levelOrderTraversal.html
UNDERSCORE
<a href="https://en.wikipedia.org/wiki/Self-organising_heuristic" target="_blank"><em>Self-organising_heuristic [Wikipedia]</em></a>. in movefront.html
BACKSLASH, CARET, or DOLLAR SIGN
<p> <img src="../Images/xkcd 0287 np_complete.png"   alt="Caption: My hobby embedding NP-complete problems in restaurant   orders. Left panel is a menu.  In the right panel, person ordering   says, 'We'd like exactly $15.05 worth of appetizers, please.'   followed by a discussion of knapsack and other np-complete problems."> <br /> in npcomplete.html
BACKSLASH, CARET, or DOLLAR SIGN
  / \								<br /> in optimalMerge.html
BACKSLASH, CARET, or DOLLAR SIGN
    /  \							<br /> in optimalMerge.html
BACKSLASH, CARET, or DOLLAR SIGN
  / \							<br /> in optimalMerge.html
BACKSLASH, CARET, or DOLLAR SIGN
    /  \        /  \				<br /> in optimalMerge.html
BACKSLASH, CARET, or DOLLAR SIGN
  / \						<br /> in optimalMerge.html
BACKSLASH, CARET, or DOLLAR SIGN
   /  \           /  \			<br /> in optimalMerge.html
BACKSLASH, CARET, or DOLLAR SIGN
      /  \				<br /> in optimalMerge.html
BACKSLASH, CARET, or DOLLAR SIGN
    / \					<br /> in optimalMerge.html
BACKSLASH, CARET, or DOLLAR SIGN
   /  \           /  \         /  \	<br /> in optimalMerge.html
BACKSLASH, CARET, or DOLLAR SIGN
      /  \				<br /> in optimalMerge.html
BACKSLASH, CARET, or DOLLAR SIGN
    / \					<br /> in optimalMerge.html
BACKSLASH, CARET, or DOLLAR SIGN
       /    \              /  \		<br /> in optimalMerge.html
BACKSLASH, CARET, or DOLLAR SIGN
      /      \           15    17	<br /> in optimalMerge.html
BACKSLASH, CARET, or DOLLAR SIGN
   /  \      /  \			<br /> in optimalMerge.html
BACKSLASH, CARET, or DOLLAR SIGN
      /  \				<br /> in optimalMerge.html
BACKSLASH, CARET, or DOLLAR SIGN
    / \					<br /> in optimalMerge.html
BACKSLASH, CARET, or DOLLAR SIGN
             /    \		<br /> in optimalMerge.html
BACKSLASH, CARET, or DOLLAR SIGN
            /      \		<br /> in optimalMerge.html
BACKSLASH, CARET, or DOLLAR SIGN
           /        \		<br /> in optimalMerge.html
BACKSLASH, CARET, or DOLLAR SIGN
       /    \       /  \		<br /> in optimalMerge.html
BACKSLASH, CARET, or DOLLAR SIGN
      /      \    15    17	<br /> in optimalMerge.html
BACKSLASH, CARET, or DOLLAR SIGN
   /  \      /  \		<br /> in optimalMerge.html
BACKSLASH, CARET, or DOLLAR SIGN
      /  \			<br /> in optimalMerge.html
BACKSLASH, CARET, or DOLLAR SIGN
    / \				<br /> in optimalMerge.html
UNDERSCORE
     postorder(tree.left_subtree);<br /> in postorderTraversal.html
UNDERSCORE
     postorder(tree.right_subtree);<br /> in postorderTraversal.html
UNDERSCORE
     preorder(tree.left_subtree);<br /> in preorderTraversal.html
UNDERSCORE
     preorder(tree.right_subtree);<br /> in preorderTraversal.html
UNDERSCORE
<li>Write a function to compute the integer square root of a non-negative integer using square_root(4x) = 2*square_root(x). (after "ML for the Working Programmer", pages 48 and 49). </ol></em> in recursion.html
BACKSLASH, CARET, or DOLLAR SIGN
         = x<sup>(1*2^3 + 1*2^2 + 0*2^1 + 1*2^0)</sup>		<br /> in repeatedSquaring.html
BACKSLASH, CARET, or DOLLAR SIGN
         = x<sup>1*2^3</sup>* x<sup>1*2^2</sup>* x<sup>0*2^1</sup>* x<sup>1*2^0</sup>		<br /> in repeatedSquaring.html
BACKSLASH, CARET, or DOLLAR SIGN
         = x<sup>2^3</sup>  * x<sup>2^2</sup>  *  1    * x<sup>2^0</sup> <br /> in repeatedSquaring.html
BACKSLASH, CARET, or DOLLAR SIGN
How do you <a href="http://ai.eecs.umich.edu/people/rounds/Winter02Slides/LectureApril4.pdf" target="_blank">compute 1415^13 mod 2537 with a calculator?</a> (PDF). To work out  <a href="http://www.tricki.org/article/To_work_out_powers_mod_n_use_repeated_squaring" target="_blank">powers mod n</a>, use repeated squaring. in repeatedSquaring.html
UNDERSCORE
<a href="https://en.wikipedia.org/wiki/Dense_graph" target="_blank"><em>Dense_graph [Wikipedia]</em></a> in sparsegraph.html
UNDERSCORE
<pre>               ___________	<br /> in squareRoot.html
BACKSLASH, CARET, or DOLLAR SIGN
             \/  6,65,64.	<br /> in squareRoot.html
UNDERSCORE
<pre>               __2________	<br /> in squareRoot.html
BACKSLASH, CARET, or DOLLAR SIGN
             \/  6,65,64.	<br /> in squareRoot.html
UNDERSCORE
 </pre> Now bring down the next two digits (65).  The next "divisor" is double the number on top (2x2=4) and some other digit in the units position (4_).  in squareRoot.html
UNDERSCORE
<pre>               __2________	<br /> in squareRoot.html
BACKSLASH, CARET, or DOLLAR SIGN
             \/  6,65,64.	<br /> in squareRoot.html
UNDERSCORE
             4_ ) 265		<br /> in squareRoot.html
UNDERSCORE
<pre>               __2__<strong>6</strong>_____	<br /> in squareRoot.html
BACKSLASH, CARET, or DOLLAR SIGN
             \/  6,65,64.	<br /> in squareRoot.html
UNDERSCORE
<pre>               __2__<strong>5</strong>_____	<br /> in squareRoot.html
BACKSLASH, CARET, or DOLLAR SIGN
             \/  6,65,64.	<br /> in squareRoot.html
UNDERSCORE
<pre>               __2__5_____	<br /> in squareRoot.html
BACKSLASH, CARET, or DOLLAR SIGN
             \/  6,65,64.	<br /> in squareRoot.html
UNDERSCORE
             50_ ) 4064		<br /> in squareRoot.html
UNDERSCORE
<pre>               __2__5__<strong>8</strong>__	<br /> in squareRoot.html
BACKSLASH, CARET, or DOLLAR SIGN
             \/  6,65,64.	<br /> in squareRoot.html
UNDERSCORE
<pre>       __1__6.8_4_0_4_2_7_5_...<br /> in squareRoot.html
BACKSLASH, CARET, or DOLLAR SIGN
     \/  2,83.6		<br /> in squareRoot.html
UNDERSCORE
<a href="pearsonshash.html"><em>Pearson's hash</em></a>, <a href="https://en.wikipedia.org/wiki/Zobrist_hashing" target="_blank"><em>Zobrist_hashing [Wikipedia]</em></a>. in tabulationHashing.html
UNDERSCORE
<pre> int max_list(list l, int max_so_far)<br /> in tailRecursion.html
UNDERSCORE
         return max_so_far;<br /> in tailRecursion.html
UNDERSCORE
     if (max_so_far < head(l)) {<br /> in tailRecursion.html
UNDERSCORE
         return max_list(tail(l), head(l));<br /> in tailRecursion.html
UNDERSCORE
         return max_list(tail(l), max_so_far);<br /> in tailRecursion.html
UNDERSCORE
<p> The return value of the current invocation is just the return value of the recursive call.  A compiler could optimize it something like the following so it doesn't allocate new space for l and max_so_far on each invocation or tear down the stack on the returns.  in tailRecursion.html
UNDERSCORE
 int max_list(list l, int max_so_far)<br /> in tailRecursion.html
UNDERSCORE
         return max_so_far;<br /> in tailRecursion.html
UNDERSCORE
     if (max_so_far < head(l)) {<br /> in tailRecursion.html
UNDERSCORE
         max_so_far = head(l);<br /> in tailRecursion.html
UNDERSCORE
         max_so_far = max_so_far;<br /> in tailRecursion.html
UNDERSCORE
<p> Of course, if a compiler is good enough to find and rewrite tail recursion, it will also collapse the loop test, eliminate the assignment of max_so_far to itself, and hoist the assignment of l after the test giving the following:  in tailRecursion.html
UNDERSCORE
 int max_list(list l, int max_so_far)<br /> in tailRecursion.html
UNDERSCORE
     if (max_so_far < head(l)) {<br /> in tailRecursion.html
UNDERSCORE
         max_so_far = head(l);<br /> in tailRecursion.html
UNDERSCORE
   return max_so_far;<br /> in tailRecursion.html
UNDERSCORE
<a href="linearSearch.html"><em>linear search</em></a>, <a href="https://en.wikipedia.org/wiki/Self-organising_heuristic" target="_blank"><em>Self-organising_heuristic [Wikipedia]</em></a>. in transposeSeqSearch.html
