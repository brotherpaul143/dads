# *created  "Mon Nov  1 10:07:45 1999" *by "Paul E. Black"
# *modified "Fri Dec 17 12:02:30 2004" *by "Paul E. Black"

# $Log: bingosort.trm,v $
# Revision 1.2  2004/12/17 17:02:30  black
# Refine XREFS into IMA, etc.  Add RCS keywords.
#

# entry name
@NAME=bingo sort
# _A_lgorithm, algo _T_echnique, _D_efinition, _P_roblem, or data _S_tructure
@TYPE=A
# autom basic theory search sort tree graph combin numeric etc. see areas.data
@AREA=sort
# the definition
@DEFN=A variant of {selection sort} that orders items by repeatedly
looking through remaining items to find the greatest value and moving
all items with that value to their final location.  This is more
efficient if there are many duplicate values.
# per Kevin <HMYINT@aol.com> 30 Oct 1999

#    These are all comma-separated lists of {cross references}
# Generalization: "I am a kind of ..."
@IMA=
# Specialization: "... is a kind of me."
@VARIANT=
# Aggregate parent: "I am a part of or used in ..."
@IMIN=
# Aggregate child: "... is a part of or used in me."
@INME=
# Other cross references that don't fit the above.  printed as "See also ..."
@XREFS={counting sort}

# any notes.  these will not be printed in the final dictionary
@NOTES=To see why it is more efficient, consider one value.  Selection
sort does one pass through remaining items for each item moved.  Bingo
sort does two passes for each value (not item): one pass to find the
next biggest value, and one pass to move every item with that value to
its final location.  Thus if on average there are more than two items
with each value, bingo sort may be faster.
# further explanation (pure HTML)
@LINKS=
# implementation(s) (pure HTML)
@IMPL=
# author's initials (see authors.data)
@AUTHOR=PEB
# end $Source: /home/black/Workspace/dads/Terms/RCS/bingosort.trm,v $
