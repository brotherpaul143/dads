# *created  "Mon Oct 19 14:50:33 1998" *by "Paul E. Black"
# *modified "Tue Aug 12 14:48:15 2003" *by "Paul E. Black"

# entry name
@NAME=bucket sort
# _A_lgorithm, _D_efinition, _P_roblem, or data _S_tructure
@TYPE=A
# basic, numeric, search, sort, graph, combin(atorial), tree, theory
@AREA=sort
# the definition
@DEFN=A {distribution sort} where input elements are initially 
distributed to several {buckets} based on an interpolation
of the element's {key}.
Each bucket is sorted if necessary, and the buckets' contents
are concatenated.
# Also Known As.  Adds an entry which is a cross reference here
@AKA=bin sort
# comma-separated list of cross references, i.e., See also ...
@XREFS={histogram sort}, {range sort}, {radix sort}, {counting sort},
{hash heap}
# any notes.  these will not be printed in the final dictionary
@NOTES=The space required is one
bucket for every few possible key value, but is {O(n log log n)#big-O
notation} taking into account a distribution of keys.  That is, some
buckets will have a lot of keys.
</P>

<P>
Bucket sorts work well for data sets where the possible key values are
known and relatively small and there are on average just a few
elements per bucket.  This means the cost of sorting the contents of
each bucket can be reduced toward zero.  The ideal result is if the
order in each bucket is uninteresting or trivial, for instance, when
each bucket holds a single key.  The buckets may be arranged so the
concatenation phase is not needed, for instance, the buckets are
contiguous parts of an array.
</P>

<P>
Bucket sorts can be {stable}.  
# further explanation (pure HTML)
@LINKS=
# implementation(s) (pure HTML)
@IMPL=
# John Morris morris@ee.uwa.edu.au
<A
HREF="http://ciips.ee.uwa.edu.au/~morris/Year2/PLDS210/binsort.html">analysis,
explanation, and code (C)</A>, and
<A
HREF="http://www.dcc.uchile.cl/~rbaeza/handbook/algs/4/423.sort.c">(C)</A>.
# author's initials
@AUTHOR=PEB
# end
