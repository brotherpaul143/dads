# *created  "Tue Sep 15 12:08:46 1998" *by "Paul E. Black"
# *modified "Thu Dec 20 11:53:38 2001" *by "Paul E. Black"

# entry name
@NAME=sieve of Eratosthenes
# _A_lgorithm, _D_efinition, _P_roblem, or data _S_tructure
@TYPE=A
# basic, search, sort, graph, combin(atorial), etc.
@AREA=numeric
# the definition
@DEFN=An algorithm to find all prime numbers up to a certain $N$.
Begin with an (unmarked) {array} of integers from 2 to $N$.  The first
unmarked integer, 2, is the first prime.  Mark every multiple of this
prime.  Repeatedly take the next unmarked integer as the next prime
and mark every multiple of the prime.
# comma-separated list of cross references, i.e., See also ...
@XREFS=
# any notes.  these will not be printed in the final dictionary
@NOTES=Invented by <A
href="http://www-groups.dcs.st-and.ac.uk/history/Mathematicians/Eratosthenes.html">Eratosthenes
of Cyrene</A> (276 BC - 194 BC).
</P>

<P>
<table border="0" cellpadding="6" cellspacing="0">
<tr>
<td colspan="26">
For example, here's a beginning array.
</td>
</tr>
<tr>
<td>2</td> <td>3</td> 
<td>4</td> <td>5</td> 
<td>6</td> <td>7</td> <td>8</td> <td>9</td> <td>10</td> 
<td>11</td> <td>12</td> <td>13</td> <td>14</td> <td>15</td> 
<td>16</td> <td>17</td> <td>18</td> <td>19</td> <td>20</td> 
<td>21</td> <td>22</td> <td>23</td> <td>24</td> <td>25</td> 
<td>26</td> <td>27</td>
</tr>
<tr>
<td colspan="26">
Since 2 is unmarked, it is our first prime.  We mark every second
integer, that is, 4, 6, 8, 10, 12, etc.
</td>
</tr>
<tr>
<td><strong><font size=+1>2</font></strong></td> <td>3</td> 
<td><strike>4</strike></td> <td>5</td> 
<td><strike>6</strike></td> <td>7</td> <td><strike>8</strike></td>
<td>9</td> 
<td><strike>10</strike></td> <td>11</td> <td><strike>12</strike></td> 
<td>13</td> <td><strike>14</strike></td> <td>15</td> 
<td><strike>16</strike></td> <td>17</td> <td><strike>18</strike></td> 
<td>19</td> <td><strike>20</strike></td> <td>21</td> 
<td><strike>22</strike></td> <td>23</td> <td><strike>24</strike></td> 
<td>25</td> <td><strike>26</strike></td> <td>27</td> 
</tr>
<tr>
<td colspan="26">
The next unmarked integer is 3, so it is prime, and we mark every
third integer, i.e., 6, 9, 12, etc.  Note that we mark 6, 12, 18,
etc. again.
</td>
</tr>
<tr>
<td><strong><font size=+1>2</font></strong></td> <td><strong><font size=+1>3</font></strong></td> 
<td><strike>4</strike></td> <td>5</td> 
<td><strike>6</strike></td> <td>7</td> 
<td><strike>8</strike></td> <td><strike>9</strike></td> 
<td><strike>10</strike></td> <td>11</td> 
<td><strike>12</strike></td> <td>13</td> <td><strike>14</strike></td> 
<td><strike>15</strike></td> <td><strike>16</strike></td> <td>17</td> 
<td><strike>18</strike></td> <td>19</td> <td><strike>20</strike></td> 
<td><strike>21</strike></td> <td><strike>22</strike></td> <td>23</td> 
<td><strike>24</strike></td> <td>25</td> 
<td><strike>26</strike></td> <td><strike>27</strike></td> 
</tr>
<tr>
<td colspan="26">
Now 5 is the next prime, and we mark every fifth integer.  The
only new integer marked in range is 25.
</td>
</tr>
<tr>
<td><strong><font size=+1>2</font></strong></td> <td><strong><font size=+1>3</font></strong></td> 
<td><strike>4</strike></td> <td><strong><font size=+1>5</font></strong></td> 
<td><strike>6</strike></td> <td>7</td>
<td><strike>8</strike></td> <td><strike>9</strike></td> 
<td><strike>10</strike></td> <td>11</td>
<td><strike>12</strike></td> <td>13</td> <td><strike>14</strike></td>
<td><strike>15</strike></td>
<td><strike>16</strike></td> <td>17</td> <td><strike>18</strike></td> 
<td>19</td> <td><strike>20</strike></td> 
<td><strike>21</strike></td> <td><strike>22</strike></td> <td>23</td> 
<td><strike>24</strike></td> <td><strike>25</strike></td>
<td><strike>26</strike></td> <td><strike>27</strike></td> 
</tr>
<tr>
<td colspan="26">
From here we find the primes 7, 11, 13, 17, etc.
</td>
</tr>
</table>
</P>


<P>
To optimize, when we find the prime $n$, we can begin marking at
$n<sup>2</sup>$, since any composite less than that is a multiple of
a lesser prime, and so will have been marked earlier.  As a corollary,
we can stop marking when $n<sup>2</sup>$ is greater than our range.
That is, any unmarked numbers greater than the square root of the
range are primes.
</P>

<P>
The naive implementation is not practical for large $N$ since the
memory is {$\Theta(N)$#$\Theta$}.  More efficient implementations use
a <A
href="http://www.utm.edu/research/primes/programs/Eratosthenes/">segmented
sieve</A>.
</P>
# further explanation (pure HTML)
@LINKS=<A
href="http://www.utm.edu/research/primes/glossary/SieveOfEratosthenes.html">explanation
and (pseudocode)</A>
# implementation(s) (pure HTML)
@IMPL=<A
href="http://www.utm.edu/research/primes/programs/Eratosthenes/">various
implementations (C, Perl, and Java)</A>,
<A
href="http://www.utm.edu/research/primes/programs/Eratosthenes/Eratosthenes.pl.txt">(Perl)</A>,
<A
href="http://members.xoom.com/yurtle/proggie/sieve.java">(java)</A>,
<A href="http://kumo.swcp.com/imagine1/ex_sieve.html">(F)</A>,
<A href="http://cat.ucsd.edu:8008/cafeobj/lib/sieve.mod">(CafeOBJ)</A>,
Stockton's Pascal Maths Page gives <A
href="http://www.merlyn.demon.co.uk/pas-math.htm#Primes">links to
three implementations</A>:
<A href="http://www.merlyn.demon.co.uk/programs/eratost1.pas">bit
array (Pascal)</A>,
<A href="http://www.merlyn.demon.co.uk/programs/eratost2.pas">bit
array for odd numbers (Pascal)</A>,
<A href="http://www.merlyn.demon.co.uk/programs/eratost3.pas">packed
bit array for odd numbers (Pascal)</A>
# author's initials
@AUTHOR=PEB
# end
